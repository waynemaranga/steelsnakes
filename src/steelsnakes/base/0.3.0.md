# Functional Checks Registry Architecture (v0.3.0)

## Overview

This document describes the planned registry-based architecture for steelsnakes checks module. The current v0.0.1-alpha-6 uses simple functions and base classes; v0.3.0 will add a functional registry for discovery, metadata, and unified execution.

## Architecture Goals

- **Purely functional**: No stateful objects, pure functions only
- **Discoverable**: Engineers can find checks by code, tags, or clause
- **Metadata-rich**: Each check carries code references, equations, descriptions
- **Unified interface**: Consistent input/output across all codes
- **Extensible**: Easy to add new codes and checks
- **Developer-friendly**: Small formula functions for composition in notebooks/apps

## Core Components

### 1. Pydantic Models

```python
class ClauseRef(BaseModel):
    """Code reference metadata."""
    code: str              # "AISC 360-22", "EN 1993-1-1"
    clause: Optional[str]  # "D2", "6.2.4"
    equation: Optional[str] # "D2-1", "6.10"
    title: Optional[str]   # "Tensile yielding on gross section"
    notes: Optional[str]   # Additional context

class Scalar(BaseModel):
    """Value with optional units and metadata."""
    value: float
    units: Optional[str] = None
    metadata: Optional[dict[str, Any]] = None

class CheckContext(BaseModel):
    """Input context for checks."""
    code: DesignCode
    material: Material    # Fy, Fu, E, G
    section: Section      # Ag, An, Wpl_y, etc. (all optional)
    member: Optional[Member] = None    # Lengths, K factors
    demands: Optional[Demands] = None  # Forces/moments
    factors: Optional[Factors] = None  # phi, gamma_M values
    assumptions: Optional[dict[str, str]] = None

class CheckResult(BaseModel):
    """Standardized check output."""
    id: str                           # "tension.gross_yielding"
    code: DesignCode
    passed: bool                      # utilization <= 1.0
    utilization: float               # demand / capacity
    demand: Optional[Scalar] = None   # Required strength/force
    capacity: Optional[Scalar] = None # Design resistance/strength
    clause: ClauseRef                # Code reference
    variables: dict[str, Union[float, Scalar]] = {}  # Intermediates
    messages: list[str] = []         # Warnings/notes
```

### 2. Functional Registry

```python
# Global registry: (code, check_id) -> (function, metadata)
_CHECK_REGISTRY: dict[tuple[DesignCode, str], tuple[Callable, RegisteredCheckInfo]] = {}

def register_check(
    check_id: str,                    # "tension.gross_yielding"
    code: DesignCode,                 # AISC_360, EN_1993
    fn: Callable[[CheckContext], CheckResult],
    clause: ClauseRef,
    tags: list[str] = [],            # ["tension", "yielding"]
    doc: Optional[str] = None
) -> None:
    """Register a check function."""

def list_checks(
    code: Optional[DesignCode] = None,
    tags: Optional[list[str]] = None
) -> list[RegisteredCheckInfo]:
    """Discover available checks."""

def run_check(code: DesignCode, check_id: str, ctx: CheckContext) -> CheckResult:
    """Execute a single check."""

def run_checks(code: DesignCode, check_ids: list[str], ctx: CheckContext) -> list[CheckResult]:
    """Execute multiple checks."""
```

### 3. Small Formula Functions

Each check is built from small, reusable formula functions:

```python
# US helpers
def nominal_tensile_strength_gross(Fy: float, Ag: float) -> float:
    """AISC D2-1: Pn = Fy * Ag"""
    return Fy * Ag

def nominal_tensile_strength_net(Fu: float, Ae: float) -> float:
    """AISC D2-2: Pn = Fu * Ae"""
    return Fu * Ae

def design_strength_lrfd(phi: float, Pn: float) -> float:
    """LRFD: Design strength = phi * Pn"""
    return phi * Pn

# EU helpers
def compression_resistance_class123(A: float, fy: float, gamma_M0: float) -> float:
    """EN 6.2.4 eq 6.10: N_cRd = A * fy / gamma_M0"""
    return (A * fy) / gamma_M0

def moment_resistance_plastic(Wpl: float, fy: float, gamma_M0: float) -> float:
    """EN 6.2.5 eq 6.13: M_cRd = Wpl * fy / gamma_M0"""
    return (Wpl * fy) / gamma_M0
```

## Check Implementation Pattern

### Auto-Registration in Module

```python
# steelsnakes/US/checks/__init__.py
from steelsnakes.base.checks import register_check, DesignCode, ClauseRef

def us_d2_1_tension_gross_yielding(ctx: CheckContext) -> CheckResult:
    """AISC D2-1: Tensile yielding on gross section."""
    # Get inputs
    Pu = ctx.demands.Pu
    Ag = ctx.section.Ag
    Fy = ctx.material.Fy
    phi_t = ctx.factors.phi_t or 0.9  # Default per code
    
    # Calculate using small functions
    Pn = nominal_tensile_strength_gross(Fy, Ag)
    phi_Pn = design_strength_lrfd(phi_t, Pn)
    utilization = compute_utilization(Pu, phi_Pn)
    
    return CheckResult(
        id="tension.gross_yielding",
        code=ctx.code,
        passed=utilization <= 1.0,
        utilization=utilization,
        demand=Scalar(value=Pu, units="force"),
        capacity=Scalar(value=phi_Pn, units="force"),
        clause=ClauseRef(code="AISC 360-22", clause="D2", equation="D2-1", 
                        title="Tensile yielding on gross section"),
        variables={"Pn": Pn, "phi_t": phi_t, "Ag": Ag, "Fy": Fy}
    )

# Auto-register on import
register_check(
    "tension.gross_yielding",
    DesignCode.AISC_360,
    us_d2_1_tension_gross_yielding,
    ClauseRef(code="AISC 360-22", clause="D2", equation="D2-1"),
    tags=["tension", "yielding"],
    doc="Tensile yielding on gross cross-section"
)
```

## Usage Patterns

### Direct Function Use (Engineers)
```python
from steelsnakes.US.checks import nominal_tensile_strength_gross, design_strength_lrfd

# Use small functions in notebooks/custom calculations
Pn = nominal_tensile_strength_gross(Fy=50000, Ag=8.5)
phi_Pn = design_strength_lrfd(phi=0.9, Pn=Pn)
print(f"Design strength: {phi_Pn} psi")
```

### Registry-Based Execution (Applications)
```python
from steelsnakes.base.checks import run_check, list_checks, CheckContext
import steelsnakes.US.checks  # Auto-registers checks

# Discover checks
checks = list_checks(code=DesignCode.AISC_360, tags=["tension"])
print([c.id for c in checks])  # ["tension.gross_yielding", "tension.net_rupture"]

# Execute checks
ctx = CheckContext(
    code=DesignCode.AISC_360,
    material=Material(Fy=50000, Fu=65000),
    section=Section(Ag=8.5, Ae=7.8),
    demands=Demands(Pu=150000),
    factors=Factors(phi_t=0.9)
)

result = run_check(DesignCode.AISC_360, "tension.gross_yielding", ctx)
print(f"Utilization: {result.utilization:.2f}, Passed: {result.passed}")
```

### Batch Processing (Design Tools)
```python
# Run all tension checks
tension_checks = [c.id for c in list_checks(DesignCode.AISC_360, tags=["tension"])]
results = run_checks(DesignCode.AISC_360, tension_checks, ctx)

# Generate report
for r in results:
    status = "PASS" if r.passed else "FAIL"
    print(f"{r.clause.equation}: {r.utilization:.2f} - {status}")
```

## Benefits

### For Engineers
- **Small functions**: Use individual formulas in notebooks and custom calculations
- **Consistent interface**: Same result format across all codes
- **Rich metadata**: Access to clause references and intermediate variables
- **Units support**: Optional units tracking (future: automatic conversion)

### For Application Developers
- **Discoverability**: Find checks by code, tags, or search
- **Dynamic execution**: Run checks by string ID from user selection
- **Batch processing**: Execute multiple checks with single context
- **Cross-code comparison**: Compare results between design codes

### For Package Maintainers
- **Extensible**: Add new codes/checks via simple registration
- **Testable**: Pure functions are easy to unit test
- **Documented**: Metadata carries code references automatically
- **Modular**: Small functions can be tested and reused independently

## Migration Strategy (v0.2.x â†’ v0.3.0)

1. **Phase 1**: Keep current simple functions, add registry alongside
2. **Phase 2**: Convert existing checks to registry pattern gradually
3. **Phase 3**: Add cross-code checks and comparison features
4. **Phase 4**: Add advanced features (units, optimization, reporting)

## Implementation Notes

- Registry populated at import time (lazy loading)
- Small functions remain public API for direct use
- Context validation happens at check execution
- Failed checks return inf utilization, not exceptions
- Metadata serializable for API/web applications
- Future: Add check dependencies and execution ordering

This architecture balances simplicity for engineers with powerful features for application developers, while maintaining the functional approach and extensibility requirements.
